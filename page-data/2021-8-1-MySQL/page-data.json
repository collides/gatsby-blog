{"componentChunkName":"component---src-templates-post-tsx","path":"/2021-8-1-MySQL/","result":{"data":{"markdownRemark":{"html":"<ol>\n<li>\n<p>一条语句是怎么执行的</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png\" alt=\"img\"></p>\n<ul>\n<li>连接器</li>\n</ul>\n<p> 负责跟客户端建立连接，获取权限、维持和管理连接，建立连接后会保持长连接默认是 8 小时自动断开,</p>\n<p> 在 MySQL 执行过程中临时使用的内存都是存储在连接对象里的当连接断开才会释放资源</p>\n<ul>\n<li>查询缓存</li>\n</ul>\n<p> 执行查询请求时会访问内存中的 K/V，如果查询到了直接返回缓存内容，但是缓存是以语句进行缓存的如果发生了数据变化会自动清除缓存如果业务不是经常变动可以使用显式指定缓存 </p>\n<p> mysql> select SQL_CACHE * from T where ID=10；</p>\n<ul>\n<li>分析器</li>\n</ul>\n<p> MySQL 先会做词法分析，识别字符串分别是什么代表什么，然后再做语法分析判断是否符合语法规范</p>\n<ul>\n<li>优化器</li>\n</ul>\n<p> 优化器是在表里有多个索引的时候决定采用哪个索引查语句顺序执行效率更快</p>\n<ul>\n<li>执行器</li>\n</ul>\n<p> 开始执行的时候先判断是否对该表有权限，查缓存的时候也会做权限校验，如果有权限就会使用指定的引擎接口对表进行查询</p>\n<ul>\n<li>调用 InnoDB 引擎接口读表第一行，如果满足条件则记录在结果集中，</li>\n<li>调用接口取下一行重复相同的判断</li>\n<li>执行期将上述遍历过程中所有满足条件的行组成记录集返回</li>\n</ul>\n</li>\n<li>\n<p>日志模块</p>\n<ul>\n<li>InnoDB 引擎的 redo log，redo log 大小是固定的可以配置为一组 4 个文件，每个大小 1GB，从头开始写写到末尾又回到开头循环写</li>\n</ul>\n<p> <img src=\"https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png\" alt=\"img\"></p>\n<p> 如果 write pos，追上 checkpoint 表示写满了，这时候不能再执行新的更新 redo log 会将强制刷盘，redo log 是物理日志记录的是 \"在某个数据页上做了什么修改\" redo log 日志分为 prepare 和 commit 阶段，提交事务前将日志状态置为 prepare 阶段然后生成这个操作的 binlog 并且将 binlog 写入磁盘，然后引擎执行提交事务，然后将 redo log 改为 commit</p>\n<ul>\n<li>binLog</li>\n</ul>\n<p> binLog 是 MySQL server 层的归档日志，binLog 是逻辑日志记录的是这个语句的原始逻辑，跟 redo log 区别在于 redo log 是循环写的，binLog 可以追加写入，并不会覆盖以前的日志</p>\n<ul>\n<li>二阶段提交</li>\n</ul>\n<p> 在两阶段提交时，若 redo log 写入成功，bin log 写入失败，则后续通过 bin log 恢复时，恢复的数据将会缺失一部分。(如 redo log 执行了 update t set status = 1，此时原库的数据 status 已更新为 1，而 bin log 写入失败，没有记录这一操作，后续备份恢复时，其 status = 0，导致数据不一致）。</p>\n<p> 若先写入 bin log，当 bin log 写入成功，而 redo log 写入失败时，原库中的 status 仍然是 0 ，但是当通过 bin log 恢复时，其记录的操作是 set status = 1，也会导致数据不一致。</p>\n<p> 其核心就是， redo log 记录的，即使异常重启，都会刷新到磁盘，而 bin log 记录的， 则主要用于备份。</p>\n</li>\n<li>\n<p>事务隔离</p>\n<p>1、事务的特性：原子性、一致性、隔离性、持久性\n2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读\n3、事务隔离级别：读未提交、读提交、可重复读、串行化\n4、不同事务隔离级别的区别：</p>\n<ul>\n<li>读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到</li>\n<li>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到</li>\n<li>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的</li>\n<li>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</li>\n</ul>\n<p>5、配置方法：启动参数 transaction-isolation\n6、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。\n7、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。\n8、什么时候不需要了？当系统里么有比这个回滚日志更早的 read-view 的时候。\n9、为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。\n10、事务启动方式：一、显式启动事务语句，begin 或者 start transaction,提交 commit，回滚 rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个 select 语句，事务就启动，并不会自动提交，直到主动执行 commit 或 rollback 或断开连接。\n11、建议使用方法一，如果考虑多一次交互问题，可以使用 commit work and chain 语法。在autocommit=1 的情况下用 begin 显式启动事务，如果执行 commit 则提交事务。如果执行 commit work and chain 则提交事务并自动启动下一个事务。</p>\n</li>\n<li>\n<p>MySQL 索引</p>\n<p>索引用于提高数据查询效率，常见的索引模型有：哈希表、有序数组、搜索树，</p>\n<ul>\n<li>哈希表：键 - 值</li>\n</ul>\n<p> 把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放到数组的这个位置，如果出现了哈希冲突的情况使用链表来解决重复问题，适用于只有等值查询的场景。</p>\n<ul>\n<li>有序数组</li>\n</ul>\n<p> 按顺序存储，查询用二分法快速查询时间复杂度是 O(log(N))，有序数组查询效率高，更新效率低，适用于静态存储引擎。</p>\n<ul>\n<li>二叉搜索树</li>\n</ul>\n<p> 每个节点的左子节点小于父节点，父节点又小于右子节点，查询和更新时间复杂度都为 O(log(N))，数据库存储大多不适合用二叉树，因为树高过高一般使用 N 叉树</p>\n<p> 索引类型：主键索引、非主键索引</p>\n<p> 主键索引的叶子节点存的是整行的数据（聚簇索引），非主键索引的叶子节点存的是主键的值（二级索引），主键和普通索引的区别：主键索引只要搜索 ID 这个 B+Tree 即可拿到数据，而普通索引会先搜索索引拿到主键值然后回主键树再取一次数据（回表）。</p>\n<p> 覆盖索引：覆盖索引可以减少因为普通索引上数据不足的情况进行回表的操作，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">mysql<span class=\"token operator\">></span> create table <span class=\"token class-name\">T</span> <span class=\"token punctuation\">(</span>ID <span class=\"token keyword\">int</span> primary key<span class=\"token punctuation\">,</span>k <span class=\"token keyword\">int</span> NOT NULL <span class=\"token class-name\">DEFAULT</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> s <span class=\"token function\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span> NOT NULL DEFAULT <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>index <span class=\"token function\">k</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>engine<span class=\"token operator\">=</span><span class=\"token class-name\">InnoDB</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p> select ID from T where k between 3 and 5 这时只需要查寻主键的值而 ID 已经存在在普通索引树上了不需要再回表。</p>\n<p> 最左前缀原则：MySQL 做词法分析、语法分析的时候是通过建立最左子树来建立语法树的，解析的过程也是从左到右所以遵循最左前缀的原则</p>\n<p> 索引下推：Index Condition Pushdown，简称 ICP。 是 MySQL 5.6 版本引入的技术优化。旨在 在“仅能利用最左前缀索的场景”下（而不是能利用全部联合索引），对不在最左前缀索引中的其他联合索引字段加以利用——在遍历索引时，就用这些其他字段进行过滤 (where 条件里的匹配)。过滤会减少遍历索引查出的主键条数，从而减少回表次数，提示整体性能。 ------------------ 如果查询利用到了索引下推 ICP 技术，在 Explain 输出的 Extra 字段中会有 “Using index condition”。即代表本次查询会利用到索引，且会利用到索引下推。 索引下推技术的实现——在遍历索引的那一步，由只传入可以利用到的字段值，改成了多传入下推字段值。</p>\n<p> B+Tree 索引树：一个数据页如果满了，按照 B+Tree 算法，新增一个数据页叫做页分裂，会导致性能下降，空间利用率会降低，当相邻的两个数据页利用率很低的时候会做数据页的合并，合并的过程是分裂过程的逆过程。</p>\n</li>\n<li>\n<p>MySQL 锁</p>\n<p>MySQL 里的锁分为：全局锁、表级锁、行级锁</p>\n<ul>\n<li>全局锁</li>\n</ul>\n<p> 对整个数据库实例加锁，加全局锁的方法：Flush tables with read lock (FTWRL)，这个命令可以 i使整个库处于只读状态，使用该命令之后，DML、DDL 语句等操作都会被阻塞，使用场景：全库逻辑备份，风险：如果在主库备份，备份期间服务不可用、如果在从库备份，备份期间不能执行主库同步的 binlog，导致主从延迟。</p>\n<ul>\n<li>表级锁</li>\n</ul>\n<p> MySQL 中表级别锁有两种：一种的表锁，一种是元数据锁 (meta data lock，MDL)，</p>\n<p> 表锁的语法是：lock tables ... read/write</p>\n<p> 可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放，lock tables 语法除了会限制别的线程读写以外还会限制本线程接下来的操作对象，对于 InnoDB 这种支持行级锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>\n<p> MDL 不需要显式使用，在访问一个表的时候会自动加上，保证读写的正确性，在对一个表做 DML 操作的时候，加 MDL 读锁 当要对表进行 DDL 操作的时候加写锁，读锁之间不互斥，读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p>\n<ul>\n<li>行级锁</li>\n</ul>\n<p> MySQL 的行锁是在引擎层由各个引擎实现的，不支持行锁意味着并发控制只能使用表锁，对于这种情况同一张表上任何时刻只能有一个更新在执行，会影响到业务并发度，InnoDB 是支持行锁的这也是 MylSAM 被 InnoDB 替代的原因之一，</p>\n<p> 二阶段锁：在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了立刻释放，而是等到事务提交后才释放。尽量将容易引起并发度的操作就在合适的位置从而减少一次操作中锁住共享数据的时间，进而提升效率</p>\n<p> 死锁：当并发系统中不同线程出现循环资源依赖，涉及到的线程都在等待别的线程释放资源，就会导致这几个线程都进入无限等待的状态。</p>\n<p> 解决死锁的两种策略：</p>\n<ul>\n<li>直接进入等待，直到超时，通过 innodb<em>lock</em>wait_timeout 来设置</li>\n<li>\n<p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务继续执行，innodb<em>deadlock</em>detect 设置为 on，死锁检测是在发生死锁的时候能被快速发现并且处理的，但它由额外的负担，如果一个事务被锁的时候，就要看看它所依赖的线程有没有被锁住，每个新来的被堵住的线程都要判断会不会由于自己的加入导致死锁，复杂度为 O(n)。</p>\n<p>1、如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关闭掉。一般不建议采用\n2、控制并发度，对应相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。\n3、将热更新的行数据拆分成逻辑上的多行来减少锁冲突，但是业务复杂度可能会大大提高。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>事务隔离机制</p>\n<p>首先要理清楚事务的启动时机，begin/start transacion 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句才会启动事务，如果想马上启动一个事务可以使用 start transaction with consistent snapshot 这个命令。</p>\n<p>MySQL 中有两个视图概念：</p>\n<ul>\n<li>一个是 view，它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果</li>\n<li>另一个是 InnoDB 在实现 MVCC 时使用到的一致性视图，即 consstent read view 用于支持 RC(Read committed，读提交) 和 RR(Repeatable Read，可重复读)隔离级别的实现</li>\n</ul>\n<p>快照在 MVCC 里是怎么工作的：在 RR 情况下，事务在启动的时候就拍了一个快照，InnoDB 里面每个事务都有一个唯一的 transaction id，它是在事务开始的时候向 InnoDB 的事务系统申请的，是按照顺序严格递增的，每行数据都是有多个版本的，可以根据当前版本和 undo log 计算出目的版本，在实现上 InnoDB 为每个事务都构造了一个数组，用来保存这个事务启动瞬间启动且未提交的所有事务 ID，数组里事务 ID 最小的值为低水位，当前系统里面已经创建过的事务 ID 的最大值为高水位，这个视图数组和高水位就组成了当前事务的一致性视图，而数据版本的可见性规则，就是基于数据的 row trx_id 和一致性视图的对比结果得到的</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png\" alt=\"img\"></p>\n<ul>\n<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>\n<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>\n<li>如果落在黄色部分，那就包括两种情况 a. 若 row trx<em>id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 row trx</em>id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>\n</ul>\n<p>更新逻辑：更新数据都是先读后写的，而这个读，只能读当前值，称为当前读 (current read)，所以 RR 其实为 读隔离。</p>\n</li>\n</ol>","excerpt":"一条语句是怎么执行的 img 连接器  负责跟客户端建立连接，获取权限、维持和管理连接，建立连接后会保持长连接默认是 8 小时自动断开,  在 MySQL 执行过程中临时使用的内存都是存储在连接对象里的当连接断开才会释放资源 查询缓存  执行查询请求时会访问内存中的 K/V，如…","tableOfContents":"","fields":{"slug":"/2021-8-1-MySQL/"},"frontmatter":{"title":"MySQL 总结","date":"Aug 01, 2021","tags":["数据库"],"keywords":[" Hui blog","zhangYunHui"],"update":"Sep 12, 2020"}}},"pageContext":{"slug":"/2021-8-1-MySQL/","series":[],"lastmod":"2020-09-12"}},"staticQueryHashes":["2027115977","694178885"]}